# 核心概念：深入 Go 的第一性原理

> 掌握一门语言，意味着不仅要熟悉其语法，更要洞悉其灵魂——那些隐藏在表面之下的设计哲学、系统架构和核心法则。

欢迎来到 Go 的核心概念模块。在这里，我们将超越 `if-else` 和 `for` 循环，深入探索 Go 语言的"第一性原理"。我们将像工程师一样，拆解这台名为"Go"的精密机器，审视它的每一个关键部件：从指导思想的源头，到并发世界的心跳，再到将代码变为现实的引擎。

本模块的文章都经过精心重构，每一篇都采用独特的视角，旨在为您提供一场富有启发性的思想之旅。

---

## 探索之旅

### [错误处理：一种构建健壮软件的哲学](./errors.md)

我们从一个至关重要的话题开始：错误。这篇文章将探讨 Go 如何将错误处理从一种事后弥补，提升为一种主动的、贯穿于软件设计全过程的哲学。

### [设计哲学：一场苏格拉底式的对话](./philosophy.md)

通过一位好奇工程师与一位 Go 智者之间的对话，我们将探寻 Go "少即是多"设计哲学背后的动机。为什么 Go 刻意选择"不做"某些事？答案就在这场思辨之中。

### [类型系统：一趟比较语言学之旅](./type-system.md)

我们将 Go 的类型系统置于更广阔的语境中，与 Java、Python 和 Rust的"语法"进行对比。通过比较，您将深刻理解 Go 在静态与动态、继承与组合之间取得的精妙平衡。

### [内存模型：并发世界的建筑蓝图](./memory-model.md)

并发编程为何如此困难？Go 的内存模型为我们提供了一份清晰的"建筑蓝图"。本文将用建筑学的类比，为您解析 `happens-before` 定律，以及它如何保证并发程序的结构稳定。

### [运行时探秘：深入 Go 程序的引擎室](./runtime.md)

Go 的高性能并发从何而来？让我们深入其"引擎室"，探寻 G-M-P 调度器、并发垃圾回收器和智能系统调用背后的秘密。您将理解 Go 是如何高效地管理成千上万的 goroutine 的。

### [编译器：从源码到机器码的流水线之旅](./compiler.md)

`go build` 命令背后是一条精密的"代码装配流水线"。我们将跟随一行代码，走完从词法分析、类型检查、SSA 生成到最终机器码生成的全过程，见证 Go 如何将文本转化为高效的可执行文件。

---

准备好了吗？让我们开始这场深入 Go 灵魂的探索之旅。 